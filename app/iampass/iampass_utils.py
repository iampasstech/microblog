import time
from flask import current_app, session
from itsdangerous import JSONWebSignatureSerializer, BadSignature
from IAMPASS.management_api import ManagementAPI
from IAMPASS.authentication_api import AuthenticationAPI
from IAMPASS.session import Session, Status

# This file contains utility functions for using the IAMPASS system.


def get_iampsss_credentials():
    # Get the application_id and application_secret for this application
    # For demo purposes they are stored in the application config but in a production
    # environment a more secure way of storing them is recommended (environment variable, key store system).
    application_id = current_app.config.get("IAMPASS_APPLICATION_ID")
    application_secret = current_app.config.get("IAMPASS_APPLICATION_SECRET")
    return application_id,application_secret


def get_management_api():
    # Returns an IAMPASS management API instance using the application credentials.
    application_id, application_secret = get_iampass_credentials()
    manager = ManagementAPI(application_id=application_id, application_secret=application_secret)
    return manager


def authenticate_user(iampass_id):
    # Authenticates the specified user.
    # iampass_id is the value passed to management API when adding the user.'
    # You can use your user id but a better approach is to create a random token and associate it with your user.
    # see User.iampass_id in models.py
    # Get the credentials required to call IAMPASS API.
    application_id, application_secret = get_iampass_credentials()

    # Create an IAMPASS authenticator
    authenticator = AuthenticationAPI(application_id=application_id,
                                      application_secret=application_secret)

    # Authentication is an asynchronous process, so periodically check the status.
    # Initiate the authentication process.
    ip_session = authenticator.authenticate_user(iampass_id)

    # Wait until the authentication succeeds or fails
    while ip_session.in_progress:
        time.sleep(2)
        ip_session.get_status()

    # Return the session status.
    return ip_session


def end_session():
    # Get the current IAMPASS session information from the Flask session and
    # end the IAMPASS session.
    session_token = session.get('ip_session')

    if session_token is not None:
        ip_session, session_user_id = decode_session_token(session_token)
        if ip_session is not None:
            ip_session.destroy()
            del session['ip_session']


def create_session_token(ip_session, user_id):
    # Creates a 'token' that stores the IAMPASS session information in a JSON token.
    # We include the user_id so that we can check that Flask.current_user.id applies to this session.
    secret_key = current_app.config["SECRET_KEY"]
    s = JSONWebSignatureSerializer(secret_key)

    session_json = Session.Schema().dumps(ip_session)

    token = s.dumps({"session": session_json, "user_id": user_id})
    return token


def decode_session_token(session_token):
    # Converts the JSON token generated by create_session_token back into an IAMPASS.Session object.
    # Returns the IAMPASS session and the user id.
    secret_key = current_app.config["SECRET_KEY"]
    s = JSONWebSignatureSerializer(secret_key)
    try:
        session_data = s.loads(session_token)
        session_json = session_data["session"]
        ip_session = Session.Schema().loads(session_json)
        user_id = session_data["user_id"]
        return ip_session, user_id

    except (BadSignature, KeyError):
        current_app.logger.debug("Failed to get session data.")
        return None, None


def is_user_authenticated(user_id):
    # Checks whether the User with id == user_id is currently authenticated.
    # Decodes the session token and checks the status of the session and whether the
    # session is for the user.
    session_token = session.get('ip_session')

    if session_token is None:
        return False
    ip_session, session_user_id = decode_session_token(session_token)

    if ip_session is not None and session_user_id is not None:
        if user_id != session_user_id:
            return False
        current_status = ip_session.get_status()
        if current_status != Status.failed:
            return ip_session.active

    return False
